<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Perlin Effect</title>
  <style id="example-css">
  body {
  display: flex;
  justify-content: center;
  align-items:center;
  background-color: black;
}
canvas {
  width: min(90vw, 360px);
  height: auto;
  display: block;
  border:4px solid white;
  margin-top: 1.25rem;
}
  </style>
</head>
<body>
<canvas id="canvas" width="400" height="600" style="zoom:150%"></canvas>

  <script id="example-js">
const PerlinApp = {
  canvas: null,
  ctx: null,
  width: 0,
  height: 0,
  perm: null,
  fadeTable: null,
  hTable: null,
  t: 0,
  step: 0.038,

  init() {
    this.canvas = document.getElementById("canvas");
    this.ctx = this.canvas.getContext("2d");
    this.width = this.canvas.width;
    this.height = this.canvas.height;

    this._initPerm();
    this._initFade();
    this._initHTable();

    this.animate = this.animate.bind(this);
    requestAnimationFrame(this.animate);
  },

  // --- perm ---
  _initPerm() {
    const p = new Uint8Array(512);
    for (let i = 0; i < 256; i++) p[i] = i;

    for (let i = 0; i < 256; i++) {
      const j = (Math.random() * 256) | 0;
      [p[i], p[j]] = [p[j], p[i]];
    }

    for (let i = 0; i < 256; i++) p[i + 256] = p[i];

    this.perm = p;
  },

  // --- fade ---
  _initFade(size = 1024) {
    const f = new Float32Array(size + 1);
    for (let i = 0; i <= size; i++) {
      const t = i / size;
      f[i] = t * t * t * (t * (t * 6 - 15) + 10);
    }
    this.fadeTable = f;
    this.tableSize = size;
  },

  // --- h(x) ---
  _initHTable() {
    const w = this.width;
    const h = new Float32Array(w + 2);

    for (let x = -1; x <= w + 1; x++) {
      if (x < w / 4 || x > (3 * w) / 4) {
        h[x + 1] = 5;
      } else {
        h[x + 1] =
          x < w / 2
            ? this._map(x, w / 4, w / 2, 5, 50)
            : this._map(x, w / 2, (3 * w) / 4, 50, 5);
      }
    }

    this.hTable = h;
  },

  _map(v, a1, b1, a2, b2) {
    return a2 + ((v - a1) * (b2 - a2)) / (b1 - a1);
  },

  // --- grad inline ---
  noise(x) {
    const perm = this.perm;
    const fade = this.fadeTable;
    const size = this.tableSize;

    const X = (x | 0) & 255;
    const xf = x - (x | 0);

    const idx = xf * size;
    const i0 = idx | 0;
    const frac = idx - i0;

    const u = fade[i0] * (1 - frac) + fade[i0 + 1] * frac;

    const a = (perm[X] & 1) === 0 ? xf : -xf;
    const b = (perm[X + 1] & 1) === 0 ? (xf - 1) : -(xf - 1);

    return (a + u * (b - a) + 1) * 0.5;
  },

  // --- animation ---
  animate() {
    const ctx = this.ctx;
    const width = this.width;
    const height = this.height;
    const hTable = this.hTable;
    const noise = this.noise.bind(this);

    ctx.fillStyle = "black";
    ctx.fillRect(0, 0, width, height);
    ctx.strokeStyle = "white";
    ctx.lineWidth = 2;

    let idx = 0;

    for (let y = 100; y <= height - 40; y += 8) {
      ctx.beginPath();
      ctx.moveTo(-1, y - hTable[0] * noise(this.t + idx * this.step));

      for (let x = 0; x <= width + 1; x++) {
        const vy = y - hTable[x + 1] * noise(this.t + idx * this.step);
        ctx.lineTo(x, vy);
        idx++; // â† KEEP peaks
      }

      ctx.lineTo(width + 1, height + 1);
      ctx.lineTo(-1, height + 1);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
    }

    this.t += 0.01;
    requestAnimationFrame(this.animate);
  }
};

PerlinApp.init();
  </script>
</body>
</html>
